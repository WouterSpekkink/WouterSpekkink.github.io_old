I"¥¡<h2 id="introduction">Introduction</h2>
<p>I wrote a non-technical post on <a href="/software/q-sopra/non-technical/2018/02/21/relationships-in-qsopra.html">relationships in Q-SoPrA</a>. One of the things I discuss there is plotting parallel edges, that is, multiple edges between the same pair of nodes. This is something I definitely wanted to be able to do, since I am interested in looking at social arrangements (of people, places, things, etc.) that can be related to each other in various ways. If I want to look at multiple relationships at the same time, being able to visualise parallel edges is a necessity. In this post I discuss some of the details of visualising parallel edges using Qtâ€™s tools for visualisation. For a visual impression of what parallel edges look like in Q-SoPrA, see the screenshot below.</p>

<p><br /><br /><a href="/assets/posts/drawing-parallel-edges-in-qt/parallel_edges.png"><img src="/assets/posts/drawing-parallel-edges-in-qt/parallel_edges.png" alt="Network Graph Widget" class="center-image" /></a><br /><br /></p>

<h2 id="some-things-we-need-for-drawing">Some things we need for drawing</h2>
<p>In this post, I will be focusing almost exclusively on the drawing of edges, but I just want to briefly touch upon some of the other basic things we need in order to visualise them. Below you see a screenshot of the Network Graph Visualisation widget with all the menus unfolded. In the middle of this screenshot you see the space where the drawing actually happens. The drawing space itself is an object of the <a href="http://doc.qt.io/qt-5/qgraphicsview.html"><code class="language-plaintext highlighter-rouge">QGraphicsViews</code> class</a>, although I should add that in Q-SoPrA I use a sub-classed version in which I re-implemented many of the member functions of this class (the same goes for most other classes I discuss in this post). The <code class="language-plaintext highlighter-rouge">QGraphicsView</code> object visualises objects that are included in another object of the <a href="http://doc.qt.io/qt-5/qgraphicsscene.html"><code class="language-plaintext highlighter-rouge">QGraphicsScene</code> class</a> (a <code class="language-plaintext highlighter-rouge">QGraphicsScene</code> object needs to be assigned to the <code class="language-plaintext highlighter-rouge">QGraphicsView</code> object). These classes are quite well documented in the Qt documentation, so I will not go into details here (also see <a href="http://doc.qt.io/qt-5/graphicsview.html">this page</a> to read more about the Graphics View Framework of Qt).</p>

<p>Also, I recently read <a href="http://blog.qt.io/blog/2017/01/19/should-you-be-using-qgraphicsview/">this blog post</a>, which seems to suggest that Qt Quick is a potential replacement for the Graphics View Framework.</p>

<p><br /><br /><a href="/assets/posts/drawing-parallel-edges-in-qt/Network_Graph_Widget.png"><img src="/assets/posts/drawing-parallel-edges-in-qt/Network_Graph_Widget.png" alt="Network Graph Widget" class="center-image" /></a><br /><br /></p>

<p>In the screenshot we also see that we have drawn objects in the drawing space. We can see nodes, we can see edges, and we can see labels. All these objects are <em>items</em> that are currently included (and visible) in the <code class="language-plaintext highlighter-rouge">QGraphicsScene</code> object. The nodes are objects of a sub-classed version of the <a href="http://doc.qt.io/qt-5/qgraphicsitem.html"><code class="language-plaintext highlighter-rouge">QGraphicsItem</code> class</a>, the edges are objects of a sub-classed version of the <a href="http://doc.qt.io/qt-5/qgraphicslineitem.html"><code class="language-plaintext highlighter-rouge">QGraphicsLineItem</code> class</a>, and the labels are objects of a sub-classed version of the <a href="http://doc.qt.io/qt-5/qgraphicstextitem.html"><code class="language-plaintext highlighter-rouge">QGraphicsTextItem</code> class</a>.</p>

<p>So, the <code class="language-plaintext highlighter-rouge">QGraphicsView</code>, the <code class="language-plaintext highlighter-rouge">QGraphicsScene</code> and the <code class="language-plaintext highlighter-rouge">QGraphicsItem</code> are the three basic types of objects that you need to make visualisations like the ones included in Q-SoPrA. The <code class="language-plaintext highlighter-rouge">QGraphicsItem</code>s are the things we want to visualise, the <code class="language-plaintext highlighter-rouge">QGraphicsScene</code> contains and manages these items, and the <code class="language-plaintext highlighter-rouge">QGraphicsViews</code> visualises the contents of the <code class="language-plaintext highlighter-rouge">QGraphicsScene</code>.</p>

<h2 id="drawing-edges-some-basics">Drawing edges: some basics</h2>
<p>Before I get into some specific challenges related to drawing parallel edges, it is useful to briefly discuss what goes into drawing a basic edge. There are a few basic properties of edges that we need to take into account:</p>

<ol>
  <li>An edge is mostly a <em>line</em> with a <em>starting point</em> (the centre of a source node) and an <em>end point</em> (the centre of a target node). Where we draw an edge will depend on where its source and target nodes are located. We thus need to somehow explicitly relate source and target nodes to edges, so that the edges can check their nodesâ€™ locations before â€˜drawing themselvesâ€™.</li>
  <li>To indicate the direction of edges we use <em>arrowheads</em>. We thus need a way to draw these, which is a bit more complicated than just drawing a line.</li>
  <li>The <em>arrowhead</em> should point at the target node, which means that the <em>line</em> we attach it to should stop a small distance before it reaches its <em>end point</em>. Otherwise the arrowhead would simply overlap with the target node (see screenshot below; I set the z-level of the source node lower than that of the edge to make clear from where to where we draw the edgeâ€™s line).</li>
</ol>

<p><br /><br /><a href="/assets/posts/drawing-parallel-edges-in-qt/Wrong_Right_Edge.png"><img src="/assets/posts/drawing-parallel-edges-in-qt/Wrong_Right_Edge.png" alt="Wrong and Right" class="center-image" /></a><br /><br /></p>

<p>In Qtâ€™s documentation you can find the <a href="http://doc.qt.io/qt-5/qtwidgets-graphicsview-diagramscene-example.html">Diagram Scene example</a> that achieves almost exactly this (see especially the <a href="http://doc.qt.io/qt-5/qtwidgets-graphicsview-diagramscene-arrow-h.html">header file</a> and the <a href="http://doc.qt.io/qt-5/qtwidgets-graphicsview-diagramscene-arrow-cpp.html">cpp file</a> of the Arrow class used in this example). The objects that Q-SoPrA uses to draw edges are inspired by this example, although the classes ended up looking quite different due to various specific requirements I had for my own class.  The class I developed is called <code class="language-plaintext highlighter-rouge">DirectedEdge</code>, and it is what I will focus upon in the remainder of this post.</p>

<p>Let us first take a look at the constructor of the <code class="language-plaintext highlighter-rouge">DirectedEdge</code> class. Here is a code snippet from which I have removed some details that are not important for the examples in this post.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">DirectedEdge</span><span class="o">::</span><span class="n">DirectedEdge</span><span class="p">(</span><span class="n">NetworkNode</span> <span class="o">*</span><span class="n">startItem</span><span class="p">,</span> <span class="n">NetworkNode</span> <span class="o">*</span><span class="n">endItem</span><span class="p">,</span> <span class="n">QString</span> <span class="n">submittedType</span><span class="p">,</span>
			   <span class="n">QString</span> <span class="n">submittedName</span><span class="p">,</span> <span class="n">QGraphicsItem</span> <span class="o">*</span><span class="n">parent</span><span class="p">)</span>
  <span class="o">:</span> <span class="n">QGraphicsLineItem</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span> 
<span class="p">{</span>
  <span class="n">start</span> <span class="o">=</span> <span class="n">startItem</span><span class="p">;</span>
  <span class="n">end</span> <span class="o">=</span> <span class="n">endItem</span><span class="p">;</span>
  <span class="n">color</span> <span class="o">=</span> <span class="n">Qt</span><span class="o">::</span><span class="n">black</span><span class="p">;</span>
  <span class="n">setPen</span><span class="p">(</span><span class="n">QPen</span><span class="p">(</span><span class="n">color</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">Qt</span><span class="o">::</span><span class="n">SolidLine</span><span class="p">,</span> <span class="n">Qt</span><span class="o">::</span><span class="n">RoundCap</span><span class="p">,</span> <span class="n">Qt</span><span class="o">::</span><span class="n">RoundJoin</span><span class="p">));</span>
  <span class="n">height</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
  <span class="n">relType</span> <span class="o">=</span> <span class="n">submittedType</span><span class="p">;</span>
  <span class="n">name</span> <span class="o">=</span> <span class="n">submittedName</span><span class="p">;</span>
  <span class="n">filtered</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
  <span class="n">massHidden</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
  <span class="n">setFlag</span><span class="p">(</span><span class="n">QGraphicsItem</span><span class="o">::</span><span class="n">ItemSendsGeometryChanges</span><span class="p">);</span>
  <span class="n">comment</span> <span class="o">=</span> <span class="s">""</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>As you can see, we are passing pointers to objects of the <code class="language-plaintext highlighter-rouge">NetworkNode</code> class to the constructor of <code class="language-plaintext highlighter-rouge">DirectedEdge</code>. The <code class="language-plaintext highlighter-rouge">NetworkNode</code> class is a sub-classed version I created of the <a href="http://doc.qt.io/qt-5/qgraphicsitem.html"><code class="language-plaintext highlighter-rouge">QGraphicsItem</code> class</a>, and I use this class to draw the nodes of my network diagrams. When we add <code class="language-plaintext highlighter-rouge">NetworkNode</code>s (or any other <code class="language-plaintext highlighter-rouge">QGraphicsItem</code> to a <code class="language-plaintext highlighter-rouge">QGraphicsScene</code> object, then these will be assigned a <em>scene position</em>, that is, a point in the scene that is defined by an x-coordinate and a y-coordinate. We can access the <em>scene position</em> of a <code class="language-plaintext highlighter-rouge">NetworkNode</code> (or other types of <code class="language-plaintext highlighter-rouge">QGraphicsItems</code>) by using the <a href="http://doc.qt.io/qt-5/qgraphicsitem.html#scenePos">â€˜scenePos()â€™ member function</a>. This will return a <a href="http://doc.qt.io/qt-5/qpointf.html">â€˜QPointFâ€™ object</a> that contains the itemâ€™s coordinates. So, if we want to know from where to where to draw a certain edge, the obvious thing to do would be to first find the <em>scene positions</em> of its start node - start-&gt;scenePos() - and end node - end-&gt;scenePos() - and then draw the line between those two positions.</p>

<p>As I mentioned before, we actually want our line to stop shortly before it reaches its end point. What we could do is to create a <a href="http://doc.qt.io/qt-5/qlinef.html"><code class="language-plaintext highlighter-rouge">QLineF</code> object</a>, passing our start and end points as parameters, and then use the <code class="language-plaintext highlighter-rouge">setLength()</code> function to make the line slightly shorter: <code class="language-plaintext highlighter-rouge">myLine.setLength(myLine.length() - 18)</code>.</p>

<p>Then we still need to add our arrowhead. For this, I simply followed the <a href="http://doc.qt.io/qt-5/qtwidgets-graphicsview-diagramscene-example.html">Diagram Scene Example</a> provided in the online documentation for Qt. Basically, this involves creating a <a href="http://doc.qt.io/qt-5/qpolygonf.html"><code class="language-plaintext highlighter-rouge">QPolygonF</code></a> object with the shape of our arrowhead, and have this object drawn near the end point of our line.</p>

<p>We should do most of the above in the <a href="http://doc.qt.io/qt-5/qgraphicsitem.html#paint">â€˜paint()â€™ function</a> of our edge, because that is the function where we determine where and how the edge is drawn. I have included a code snippet below to illustrate what our <code class="language-plaintext highlighter-rouge">paint()</code> function might look like in this scenario.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">const</span> <span class="n">qreal</span> <span class="n">Pi</span> <span class="o">=</span> <span class="mf">3.14</span><span class="p">;</span>

<span class="kt">void</span> <span class="n">DirectedEdge</span><span class="o">::</span><span class="n">paint</span><span class="p">(</span><span class="n">QPainter</span> <span class="o">*</span><span class="n">painter</span><span class="p">,</span> <span class="k">const</span> <span class="n">QStyleOptionGraphicsItem</span> <span class="o">*</span><span class="p">,</span> <span class="n">QWidget</span> <span class="o">*</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">QPen</span> <span class="n">myPen</span> <span class="o">=</span> <span class="n">pen</span><span class="p">();</span> <span class="c1">// We need to create a pen for our painter...</span>
  <span class="n">myPen</span><span class="p">.</span><span class="n">setColor</span><span class="p">(</span><span class="n">color</span><span class="p">);</span> <span class="c1">// ...and indicate which colour it will use.</span>
  <span class="n">painter</span><span class="o">-&gt;</span><span class="n">setPen</span><span class="p">(</span><span class="n">myPen</span><span class="p">);</span> <span class="c1">// Now we set the pen to your painter.</span>
  <span class="n">QLineF</span> <span class="n">myLine</span> <span class="o">=</span> <span class="n">QLineF</span><span class="p">(</span><span class="n">start</span><span class="o">-&gt;</span><span class="n">scenePos</span><span class="p">(),</span> <span class="n">end</span><span class="o">-&gt;</span><span class="n">scenePos</span><span class="p">());</span> <span class="c1">// Here we create our line.</span>
  <span class="n">myLine</span><span class="p">.</span><span class="n">setLength</span><span class="p">(</span><span class="n">myLine</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span class="o">-</span> <span class="mi">20</span><span class="p">);</span> <span class="c1">// We shorten our line.</span>
  
  <span class="c1">// And then we create our arrowHead.</span>
  <span class="n">qreal</span> <span class="n">arrowSize</span> <span class="o">=</span> <span class="mf">10.0</span><span class="p">;</span>
  <span class="n">QPointF</span> <span class="n">arrowP1</span> <span class="o">=</span> <span class="n">myLine</span><span class="p">.</span><span class="n">p2</span><span class="p">()</span> <span class="o">-</span> <span class="n">QPointF</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">angle</span> <span class="o">+</span> <span class="n">Pi</span> <span class="o">/</span><span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="n">arrowSize</span><span class="p">,</span>
    <span class="n">cos</span><span class="p">(</span><span class="n">angle</span> <span class="o">+</span> <span class="n">Pi</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="n">arrowSize</span><span class="p">);</span>
  <span class="n">QPointF</span> <span class="n">arrowP2</span> <span class="o">=</span> <span class="n">myLine</span><span class="p">.</span><span class="n">p2</span><span class="p">()</span> <span class="o">-</span> <span class="n">QPointF</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">angle</span> <span class="o">+</span> <span class="n">Pi</span> <span class="o">-</span> <span class="n">Pi</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="n">arrowSize</span><span class="p">,</span>
  <span class="n">cos</span><span class="p">(</span><span class="n">angle</span> <span class="o">+</span> <span class="n">Pi</span> <span class="o">-</span> <span class="n">Pi</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="n">arrowSize</span><span class="p">);</span>
  
  <span class="n">arrowHead</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
  <span class="n">arrowHead</span> <span class="o">&lt;&lt;</span> <span class="n">myLine</span><span class="p">.</span><span class="n">p2</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">arrowP1</span> <span class="o">&lt;&lt;</span> <span class="n">arrowP2</span><span class="p">;</span>

  <span class="n">painter</span><span class="o">-&gt;</span><span class="n">drawLine</span><span class="p">(</span><span class="n">myLine</span><span class="p">);</span>
  <span class="n">painter</span><span class="o">-&gt;</span><span class="n">drawPolygon</span><span class="p">(</span><span class="n">arrowHead</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>And that should do the trick. At least, if we were only interested in drawing edges as straight lines. However, what if we want to draw parallel edges, that is, multiple edges between the same pair of nodes? In this case, if we would just use straight lines, then the edges would overlap, and we would actually not be able to see that multiple edges exist between our nodes. In this case, it is better to draw edges as curved lines, and to change the strength of the curve for each additional edge that we add to a given pair of nodes. The remainder of this post will be about how we can do this, and what challenges we will face.</p>

<h2 id="drawing-parallel-edges">Drawing parallel edges</h2>

<p>Drawing a curved line with the Qt library is not difficult to do. One of the easiest ways to <code class="language-plaintext highlighter-rouge">paint()</code> a curved line is by creating a <a href="http://doc.qt.io/qt-5/qpainterpath.html"><code class="language-plaintext highlighter-rouge">QPainterPath</code> object</a>, and use its <a href="http://doc.qt.io/qt-5/qpainterpath.html#quadTo"><code class="language-plaintext highlighter-rouge">quadTo()</code> function</a>. This function takes two arguments: One of the arguments is the end point that we want to draw the curved line to, and the other argument is a so-called control point that we will use to determine how the line will be curved (how strong the curve will be and which direction it will curve in). We do not give the function a starting point. Instead, we should move the <code class="language-plaintext highlighter-rouge">QPainterPath</code> object to our starting point using its <a href="http://doc.qt.io/qt-5/qpainterpath.html#moveTo">â€˜moveTo()â€™ function</a> before calling the <code class="language-plaintext highlighter-rouge">quadTo()</code> function.</p>

<p>So, what about this control point? Consider the image I have linked to below (found through this <a href="https://stackoverflow.com/questions/50129580/program-to-find-line-segment-and-bezier-curve-intersection">Stack OverFlow</a> discussion). The image shows nicely how the control point works. It is a point somewhere â€˜aboveâ€™ the place where we want our line to curve towards the control point. In the image you see that if we place the control point somewhere above the middle of the line, then the line will also curve around its middle point. This is exactly what I wanted for my parallel edges. In the image you also see that the curve will change if we move the control point closer to the starting point or the end point. This is something that I want to avoid.</p>

<p><br /><br /><a href="https://www.andrew.cmu.edu/course/98-222/lecture/lec7/img/quadraticcurve.gif"><img src="https://www.andrew.cmu.edu/course/98-222/lecture/lec7/img/quadraticcurve.gif" alt="Bezier curves" class="center-image" /></a><br /><br /></p>

<p>So far so good. Assume that our starting point is at coordinates <code class="language-plaintext highlighter-rouge">(0, 5)</code> in the scene, and our end point is at coordinate <code class="language-plaintext highlighter-rouge">(10, 5)</code> in the scene, we can first simply calculate the point that lies exactly in between them: <code class="language-plaintext highlighter-rouge">x = (10 + 0) / 2 = 5</code> and <code class="language-plaintext highlighter-rouge">y = (5 + 5) / 2 = 5</code>, giving us the point at coordinates <code class="language-plaintext highlighter-rouge">(5, 5)</code>. Then we still need to set the â€˜heightâ€™ of the curve, which, in this case, we can do simply by adding some constant to the y-coordinate of our middle point, giving us, for example, the point at coordinates <code class="language-plaintext highlighter-rouge">(5, 25)</code>. If we then pass this point to the <code class="language-plaintext highlighter-rouge">quadTo()</code> function, we will get a nice curved line.</p>

<p>This example was relatively simple, because the slope of the straight line between our starting point and our end point is 0. This makes finding the control point relatively straightforward. However, consider now that we have a line that starts at coordinates <code class="language-plaintext highlighter-rouge">(0, 5)</code> and ends at coordinates <code class="language-plaintext highlighter-rouge">(10, 10)</code>. Finding the point that lies exactly in the middle is still quite easy: <code class="language-plaintext highlighter-rouge">x = (0 + 10) / 2 = 5</code> and <code class="language-plaintext highlighter-rouge">y = 5 + 10 / 2 = 7.5</code>. However, how do we now find the control point, somewhere â€˜aboveâ€™ this middle point? We cannot simply add a constant value to the y-coordinate of our middle point, because that would place the control point somewhere right from the middle of the line, and create a curve that skews to the left (similar to the left part of the picture above, where the line is skewed to the right).</p>

<p>There are multiple possible solutions here. One thing we could do is to simply (1) calculate the distance between the start point and end point of the edge (using the pythagorean theorem), (2) draw an imaginary straight line from our start point with a slope of 0 (that is, parallel to our x-axis), and with a length that equals the distance we measured in step 1, (3) create a curved edge from the start and end point of our imaginary straight line, using the procedure described above, (4) calculate the angle between our imaginary straight line and the sloped line from our original starting point to our original end point, and then (5) <a href="http://doc.qt.io/archives/qt-4.8/qpainter.html#rotate">rotate()</a> the painter by the number of degrees of that angle before drawing our edge. In effect, we are just drawing a curved edge between two points on a horizontal line, and we are then rotating that edge before it is drawn, thereby changing its end point. This is the solution I used for a while, because it is relatively simple to implement. However, it does cause some complications for calculating the <a href="http://doc.qt.io/qt-5/qgraphicsitem.html#boundingRect">bounding rect</a> and the <a href="http://doc.qt.io/qt-5/qgraphicsitem.html#shape">shape</a> of the edge, because we are essentially working in multiple coordination systems. I will not discuss these complications in detail here, but it is important to know that they can cause unwanted behaviour in visualisations.</p>

<p>There is another, better solution that I eventually switched to after experiencing issues with my first solution. This solution starts with drawing an imaginary straight line between the start and the end points of our edge. We then calculate the midpoint of our line, as before. Then we draw a straight line perpendicular to our first line that crosses our midpoint, and we pick a point on that line as our control point. This sounds relatively straightforward, but it took me some time to figure out how to properly implement the formula for setting the control point.</p>

<p>Rather than including all these steps in the <a href="http://doc.qt.io/qt-5/qgraphicsitem.html#paint">â€˜paint()â€™ function</a> of our edge, I wrote a separate <code class="language-plaintext highlighter-rouge">calculate()</code> function that makes the necessary calculations, and is called by the paint function (as well as by other functions that require knowledge of the control pointâ€™s position). See the two functions in the code snippet below.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">void</span> <span class="n">DirectedEdge</span><span class="o">::</span><span class="n">calculate</span><span class="p">()</span> 
<span class="p">{</span>
  <span class="c1">// We first calculate the distance covered by our edge</span>
  <span class="n">qreal</span> <span class="n">dX</span> <span class="o">=</span> <span class="n">end</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">().</span><span class="n">x</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">().</span><span class="n">x</span><span class="p">();</span>
  <span class="n">qreal</span> <span class="n">dY</span> <span class="o">=</span> <span class="n">end</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">().</span><span class="n">y</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">().</span><span class="n">y</span><span class="p">();</span>
  <span class="n">qreal</span> <span class="n">distance</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">pow</span><span class="p">(</span><span class="n">dX</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">pow</span><span class="p">(</span><span class="n">dY</span><span class="p">,</span> <span class="mi">2</span><span class="p">));</span>
  <span class="c1">// Then we create a straight line from our start point to our end point and shorten its length</span>
  <span class="n">QLineF</span> <span class="n">newLine</span> <span class="o">=</span> <span class="n">QLineF</span><span class="p">(</span><span class="n">start</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">(),</span> <span class="n">end</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">());</span>
  <span class="n">newLine</span><span class="p">.</span><span class="n">setLength</span><span class="p">(</span><span class="n">newLine</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span class="o">-</span> <span class="mi">18</span><span class="p">);</span>
  <span class="c1">// Then we calculate the coordinates of our midpoint</span>
  <span class="n">qreal</span> <span class="n">mX</span> <span class="o">=</span> <span class="p">(</span><span class="n">start</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">().</span><span class="n">x</span><span class="p">()</span> <span class="o">+</span> <span class="n">newLine</span><span class="p">.</span><span class="n">p2</span><span class="p">().</span><span class="n">x</span><span class="p">())</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
  <span class="n">qreal</span> <span class="n">mY</span> <span class="o">=</span> <span class="p">(</span><span class="n">start</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">().</span><span class="n">y</span><span class="p">()</span> <span class="o">+</span> <span class="n">newLine</span><span class="p">.</span><span class="n">p2</span><span class="p">().</span><span class="n">y</span><span class="p">())</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
  <span class="c1">// And the coordinates of our control point. We use the edges height as a scaling factor</span>
  <span class="c1">// to determine the 'height' of the control point on a line perpendicular to our </span>
  <span class="c1">// original line (newLine).</span>
  <span class="n">qreal</span> <span class="n">cX</span> <span class="o">=</span> <span class="n">height</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="p">(</span><span class="n">dY</span> <span class="o">/</span> <span class="n">distance</span><span class="p">))</span> <span class="o">+</span> <span class="n">mX</span><span class="p">;</span>
  <span class="n">qreal</span> <span class="n">cY</span> <span class="o">=</span> <span class="n">height</span> <span class="o">*</span> <span class="p">(</span><span class="n">dX</span> <span class="o">/</span> <span class="n">distance</span><span class="p">)</span> <span class="o">+</span> <span class="n">mY</span><span class="p">;</span>
  <span class="n">controlPoint</span> <span class="o">=</span> <span class="n">QPointF</span><span class="p">(</span><span class="n">cX</span><span class="p">,</span> <span class="n">cY</span><span class="p">);</span>
  <span class="c1">// We create another line from our control point to our end point and shorten its length</span>
  <span class="n">ghostLine</span> <span class="o">=</span> <span class="n">QLineF</span><span class="p">(</span><span class="n">controlPoint</span><span class="p">,</span> <span class="n">end</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">());</span>
  <span class="n">ghostLine</span><span class="p">.</span><span class="n">setLength</span><span class="p">(</span><span class="n">ghostLine</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span class="o">-</span> <span class="mi">18</span><span class="p">);</span>
  <span class="c1">// Then we do the calculations we need to create our arrowhead</span>
  <span class="kt">double</span> <span class="n">angle</span> <span class="o">=</span> <span class="o">::</span><span class="n">acos</span><span class="p">(</span><span class="n">ghostLine</span><span class="p">.</span><span class="n">dx</span><span class="p">()</span> <span class="o">/</span> <span class="n">ghostLine</span><span class="p">.</span><span class="n">length</span><span class="p">());</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">ghostLine</span><span class="p">.</span><span class="n">dy</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">angle</span> <span class="o">=</span> <span class="p">(</span><span class="n">Pi</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="n">angle</span><span class="p">;</span>
  <span class="n">qreal</span> <span class="n">arrowSize</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
  <span class="n">arrowP1</span> <span class="o">=</span> <span class="n">ghostLine</span><span class="p">.</span><span class="n">p2</span><span class="p">()</span> <span class="o">-</span> <span class="n">QPointF</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">angle</span> <span class="o">+</span> <span class="n">Pi</span> <span class="o">/</span><span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="n">arrowSize</span><span class="p">,</span>
				     <span class="n">cos</span><span class="p">(</span><span class="n">angle</span> <span class="o">+</span> <span class="n">Pi</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="n">arrowSize</span><span class="p">);</span>
  <span class="n">arrowP2</span> <span class="o">=</span> <span class="n">ghostLine</span><span class="p">.</span><span class="n">p2</span><span class="p">()</span> <span class="o">-</span> <span class="n">QPointF</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">angle</span> <span class="o">+</span> <span class="n">Pi</span> <span class="o">-</span> <span class="n">Pi</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="n">arrowSize</span><span class="p">,</span>
				     <span class="n">cos</span><span class="p">(</span><span class="n">angle</span> <span class="o">+</span> <span class="n">Pi</span> <span class="o">-</span> <span class="n">Pi</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="n">arrowSize</span><span class="p">);</span>
  <span class="c1">// We set the new line as the line for this edge object and communicate that we </span>
  <span class="c1">// are about to change the objects geometry (this will makes sure the bounding rect</span>
  <span class="c1">// is reset as well.</span>
  <span class="n">setLine</span><span class="p">(</span><span class="n">newLine</span><span class="p">);</span>
  <span class="n">prepareGeometryChange</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">DirectedEdge</span><span class="o">::</span><span class="n">paint</span><span class="p">(</span><span class="n">QPainter</span> <span class="o">*</span><span class="n">painter</span><span class="p">,</span> <span class="k">const</span> <span class="n">QStyleOptionGraphicsItem</span> <span class="o">*</span><span class="p">,</span> <span class="n">QWidget</span> <span class="o">*</span><span class="p">)</span> 
<span class="p">{</span>
  <span class="c1">// We have to set a pen and its colours.</span>
  <span class="n">QPen</span> <span class="n">myPen</span> <span class="o">=</span> <span class="n">pen</span><span class="p">();</span>
  <span class="n">myPen</span><span class="p">.</span><span class="n">setColor</span><span class="p">(</span><span class="n">color</span><span class="p">);</span>
  <span class="n">painter</span><span class="o">-&gt;</span><span class="n">setPen</span><span class="p">(</span><span class="n">myPen</span><span class="p">);</span>
  <span class="n">painter</span><span class="o">-&gt;</span><span class="n">setBrush</span><span class="p">(</span><span class="n">color</span><span class="p">);</span>
  <span class="c1">// We call the calculate function outlined above.</span>
  <span class="n">calculate</span><span class="p">();</span>
  <span class="c1">// We create the arrowhead, using ghostLine (from the control point to slight before the end point)</span>
  <span class="c1">// to determine the direction from which the arrow is pointing.</span>
  <span class="n">arrowHead</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
  <span class="n">arrowHead</span> <span class="o">&lt;&lt;</span> <span class="n">ghostLine</span><span class="p">.</span><span class="n">p2</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">arrowP1</span> <span class="o">&lt;&lt;</span> <span class="n">arrowP2</span><span class="p">;</span>
  <span class="c1">// We create a path object as a based for our curved edge.</span>
  <span class="n">QPainterPath</span> <span class="n">myPath</span><span class="p">;</span>
  <span class="c1">// We move this path to the start point of our edge.</span>
  <span class="n">myPath</span><span class="p">.</span><span class="n">moveTo</span><span class="p">(</span><span class="n">start</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">());</span>
  <span class="c1">// The we create a bezier curve to our end point, using the control point to curve it</span>
  <span class="n">myPath</span><span class="p">.</span><span class="n">quadTo</span><span class="p">(</span><span class="n">controlPoint</span><span class="p">,</span> <span class="n">ghostLine</span><span class="p">.</span><span class="n">p2</span><span class="p">());</span>
  <span class="n">strokePath</span> <span class="o">=</span> <span class="n">myPath</span><span class="p">;</span>
  <span class="c1">// And then we draw the arrowhead and the curved line</span>
  <span class="n">painter</span><span class="o">-&gt;</span><span class="n">drawPolygon</span><span class="p">(</span><span class="n">arrowHead</span><span class="p">);</span>
  <span class="n">painter</span><span class="o">-&gt;</span><span class="n">strokePath</span><span class="p">(</span><span class="n">myPath</span><span class="p">,</span> <span class="n">QPen</span><span class="p">(</span><span class="n">color</span><span class="p">));</span>
<span class="p">}</span></code></pre></figure>

<h2 id="a-few-other-things-to-note-about-these-functions">A few other things to note about these functions</h2>
<p>In addition to finding the control point (which I explained above how to do), there are a few other things we need to do to make sure that we end up with nice looking curved edges. First of all, we might have 3 or more parallel edges between the same nodes. If we want to make all edges visible, we need to increase the strength of the curve for each parallel edge that we add (to prevent them from overlapping). That is what the <code class="language-plaintext highlighter-rouge">height</code> scaling factor in the snippet above is used for. This height has to be set explicitly, for which I wrote a very simple function. Then it is simply a matter of keeping track of what edges we already have in our <code class="language-plaintext highlighter-rouge">scene</code> and to make sure that the <code class="language-plaintext highlighter-rouge">height</code>s of the curves of our edges are adjusted accordingly. This is something that needs to be handled at a higher level, and I will not discuss it any further here.</p>

<p>We also need to make sure that our arrowhead actually points <em>from</em> the right direction. If we would attach our arrowhead to the original line we draw from the start point to the end point, it would make an awkward angle, as shown in the screenshot below.</p>

<p><br /><br /><a href="/assets/posts/drawing-parallel-edges-in-qt/Wrong_Arrowhead.png"><img src="/assets/posts/drawing-parallel-edges-in-qt/Wrong_Arrowhead.png" alt="Awkward arrowhead" class="center-image" /></a><br /><br /></p>

<p>This is relatively easy to correct with the resources that we already have. In the code snippet that I included above, you will see that I created an object that I called <code class="language-plaintext highlighter-rouge">ghostLine</code>, which is a line that runs from the control point that we calculated for the bezier curve to the end point of the edge (minus a small distance to prevent the line from overlapping with the node). This <code class="language-plaintext highlighter-rouge">ghostLine</code> is useful for determining where the curved edge should end, as well as for determining the angle that the arrowhead should point from. Essentially, what we can do is attach the arrowhead to the <code class="language-plaintext highlighter-rouge">ghostLine</code> and draw the arrowhead, but not draw the line itself. For illustrative purposes, I included a screenshot below where the <code class="language-plaintext highlighter-rouge">ghostLine</code> is drawn, so that you can get an idea of how it helps to determine the angle of the arrowhead.</p>

<p><br /><br /><a href="/assets/posts/drawing-parallel-edges-in-qt/Midpoint_Line.png"><img src="/assets/posts/drawing-parallel-edges-in-qt/Midpoint_Line.png" alt="Correct arrowhead" class="center-image" /></a><br /><br /></p>

<h2 id="final-comments">Final comments</h2>

<p>And that is it. The code snippets above contain the most essential ingredients for drawing curved edges within the Qt Framework. Indeed, there is plenty of stuff that goes on around this that needs to be implemented for all of this to work. Later this year, the source code for Q-SoPrA will be open, which gives you the opportunity to examine the code in more detail.</p>

:ET